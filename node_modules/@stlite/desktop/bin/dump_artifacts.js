#!/usr/bin/env node
var D=Object.create;var m=Object.defineProperty;var T=Object.getOwnPropertyDescriptor;var S=Object.getOwnPropertyNames;var O=Object.getPrototypeOf,q=Object.prototype.hasOwnProperty;var f=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports);var P=(e,t,r,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of S(t))!q.call(e,o)&&o!==r&&m(e,o,{get:()=>t[o],enumerable:!(i=T(t,o))||i.enumerable});return e};var s=(e,t,r)=>(r=e!=null?D(O(e)):{},P(t||!e||!e.__esModule?m(r,"default",{value:e,enumerable:!0}):r,e));var h=f(d=>{"use strict";Object.defineProperty(d,"__esModule",{value:!0});d.parseRequirementsTxt=void 0;function $(e){return e.split(`
`).filter(t=>!t.startsWith("#")).map(t=>t.trim()).filter(t=>t!=="")}d.parseRequirementsTxt=$});var g=f(c=>{"use strict";var j=c&&c.__createBinding||(Object.create?function(e,t,r,i){i===void 0&&(i=r);var o=Object.getOwnPropertyDescriptor(t,r);(!o||("get"in o?!t.__esModule:o.writable||o.configurable))&&(o={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,i,o)}:function(e,t,r,i){i===void 0&&(i=r),e[i]=t[r]}),x=c&&c.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&j(t,e,r)};Object.defineProperty(c,"__esModule",{value:!0});x(h(),c)});var w=s(require("yargs")),v=require("yargs/helpers"),a=s(require("path")),n=s(require("fs/promises")),y=s(require("fs-extra")),b=s(require("node-fetch")),_=require("pyodide"),k=s(g());global.fetch=b.default;async function C(e){console.info("Copy the build directory (the bare built app files) to this directory...");let t=a.default.resolve(__dirname,"../build");if(!(await n.default.stat(t)).isDirectory())throw new Error(`The source ${t} does not exist.`);if(t===e.copyTo){console.warn(`sourceDir == destDir (${t}). Are you in the development environment? Skip copying the directory.`);return}if(e.keepOld)try{await n.default.access(e.copyTo),console.info(`${e.copyTo} already exists. Use it and skip copying.`);return}catch{throw new Error(`${e.copyTo} does not exist even though the \`keepOld\` option is specified`)}console.log(`Copy ${t} to ${e.copyTo}`),await n.default.rm(e.copyTo,{recursive:!0,force:!0}),await y.default.copy(t,e.copyTo)}async function u(e,t){console.log(`Install the local wheel ${t}`);let r=await n.default.readFile(t),i="/tmp/"+a.default.basename(t);e.FS.writeFile(i,r);let o=e.pyimport("micropip"),l=`emfs:${i}`;console.log(`Install ${l}`),await o.install.callKwargs(l,{keep_going:!0})}async function K(e){console.info("Create the site-packages snapshot file...");let t=await(0,_.loadPyodide)();if(await t.loadPackage(["micropip"]),e.useLocalKernelWheels){let l=a.default.dirname(require.resolve("@stlite/kernel")),p=a.default.resolve(l,"../py");await u(t,a.default.join(p,"tornado/dist/tornado-6.2-py3-none-any.whl")),await u(t,a.default.join(p,"stlite-pyarrow/dist/stlite_pyarrow-0.1.0-py3-none-any.whl")),await u(t,a.default.join(p,"streamlit/lib/dist/streamlit-1.13.0-py2.py3-none-any.whl"))}else{let l=t.pyimport("micropip"),p=["https://cdn.jsdelivr.net/npm/@stlite/kernel@0.19.1/py/tornado/dist/tornado-6.2-py3-none-any.whl","https://cdn.jsdelivr.net/npm/@stlite/kernel@0.19.1/py/stlite-pyarrow/dist/stlite_pyarrow-0.1.0-py3-none-any.whl","https://cdn.jsdelivr.net/npm/@stlite/kernel@0.19.1/py/streamlit/lib/dist/streamlit-1.13.0-py2.py3-none-any.whl"];console.log("Install",p),await l.install.callKwargs(p,{keep_going:!0})}console.log(`Install the requirements ${JSON.stringify(e.requirements)}`),await t.pyimport("micropip").install.callKwargs(e.requirements,{keep_going:!0}),console.log("Archive the site-packages director(y|ies)");let i="/tmp/site-packages-snapshot.tar.gz";await t.runPythonAsync(`
    import tarfile
    import site

    site_packages_dirs = site.getsitepackages()

    tar_file_name = '${i}'
    with tarfile.open(tar_file_name, mode='w:gz') as gzf:
        for site_packages in site_packages_dirs:
            gzf.add(site_packages)
  `),console.log("Extract the archive file from EMFS");let o=t.FS.readFile(i);console.log(`Save the archive file (${e.saveTo})`),await n.default.writeFile(e.saveTo,o)}async function F(e){console.info("Copy the Streamlit app directory..."),console.log(`Copy ${e.sourceDir} to ${e.copyTo}`),await n.default.rm(e.copyTo,{recursive:!0,force:!0}),await y.default.copy(e.sourceDir,e.copyTo)}async function B(e){let t=await n.default.readFile(e,{encoding:"utf-8"});return(0,k.parseRequirementsTxt)(t)}function E(e){e.forEach(t=>{let r;try{r=new URL(t)}catch{return}if(r.protocol==="emfs:"||r.protocol==="file:")throw new Error(`"emfs:" and "file:" protocols are not allowed for the requirement (${t})`)})}(0,w.default)((0,v.hideBin)(process.argv)).command("* <appHomeDirSource> [packages..]","Put the user code and data and the snapshot of the required packages into the build artifact.",()=>{},e=>{console.info(e)}).positional("appHomeDirSource",{describe:"The source directory of the user code and data that will be mounted in the Pyodide file system at app runtime",type:"string",demandOption:!0}).positional("packages",{describe:"Package names to install.",type:"string",array:!0}).options("requirement",{describe:"Install from the given requirements file. This option can be used multiple times.",array:!0,type:"string",alias:"r",default:[]}).options("localKernelWheels",{describe:"Use the locally installed kernel wheels",type:"boolean",alias:"l",default:!1}).options("keepOldBuild",{type:"boolean",default:!1,alias:"k",describe:"Keep the existing build directory contents except appHomeDir."}).parseAsync().then(async e=>{let t=a.default.resolve(process.cwd(),"./build");try{await n.default.access(e.appHomeDirSource)}catch{throw new Error(`${e.appHomeDirSource} does not exist.`)}let r=e.packages;for(let i of e.requirement)r=r.concat(await B(i));E(r),await C({copyTo:t,keepOld:e.keepOldBuild}),await K({useLocalKernelWheels:e.localKernelWheels,requirements:r,saveTo:a.default.resolve(t,"./site-packages-snapshot.tar.gz")}),await F({sourceDir:e.appHomeDirSource,copyTo:a.default.resolve(t,"./streamlit_app")})});
